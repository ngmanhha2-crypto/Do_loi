<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>L·ªçc l·ªói th·ªùi gian X-quang (Excel/CSV ‚Üí Web)</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <style>
    body{background:#f6f8fc}
    .card{border-radius:16px}
    .table thead th{position:sticky;top:0;background:#ffffff;z-index:1}
    .nowrap{white-space:nowrap}
    .smallcode{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace}
    .kpi{font-size:1.9rem;font-weight:800}
    .muted{color:#6b7280}
    .badge-soft{background:#eef2ff;color:#3730a3;border:1px solid #e0e7ff}
    .rowerr{background:rgba(255,193,7,.10)}
    .diag{white-space:pre-wrap}
    .btn-primary{font-weight:700}
  </style>
</head>
<body>
<div class="container py-4">
  <div class="card shadow-sm p-4 mb-3">
    <div class="d-flex flex-wrap gap-2 align-items-center justify-content-between">
      <div>
        <h1 class="h4 mb-1">L·ªçc l·ªói th·ªùi gian cho <b>ca ch·ª•p X-quang</b></h1>
        <div class="muted">
          Upload <b>Excel (.xlsx)</b> ho·∫∑c <b>CSV</b> (d·ªØ li·ªáu gi·ªëng <span class="smallcode">Sheet1</span>) ‚Üí l·ªçc ca X-quang v√† b√°o l·ªói tr√πng.
        </div>
      </div>
      <div class="d-flex gap-2">
        <span class="badge badge-soft">Ch·ªß ƒë·ªÅ s√°ng</span>
        <span class="badge badge-soft">D√πng ƒë∆∞·ª£c GitHub Pages</span>
      </div>
    </div>

    <hr class="my-3">

    <div class="row g-3 align-items-end">
      <div class="col-lg-6">
        <label class="form-label">Ch·ªçn file d·ªØ li·ªáu</label>
        <input id="file" class="form-control" type="file" accept=".xlsx,.xls,.csv,.txt,.tsv" />
        <div class="form-text">
          ∆Øu ti√™n sheet <b>Sheet1</b> (n·∫øu l√† Excel). N·∫øu m·∫°ng ch·∫∑n CDN khi·∫øn kh√¥ng ƒë·ªçc ƒë∆∞·ª£c Excel, b·∫°n c√≥ th·ªÉ <b>Save As CSV UTF-8</b> r·ªìi t·∫£i CSV v√†o.
        </div>
      </div>

      <div class="col-lg-6">
        <label class="form-label">Ti√™u ch√≠ nh·∫≠n di·ªán ca X-quang</label>
        <div class="d-flex flex-wrap gap-2">
          <div class="form-check form-switch">
            <input class="form-check-input" type="checkbox" id="xqByService" checked>
            <label class="form-check-label" for="xqByService">T√™n DVKT ch·ª©a ‚Äúx-quang / xq‚Äù</label>
          </div>
          <div class="form-check form-switch">
            <input class="form-check-input" type="checkbox" id="xqByMachine" checked>
            <label class="form-check-label" for="xqByMachine">M√£ m√°y b·∫Øt ƒë·∫ßu b·∫±ng ‚ÄúXQ‚Äù</label>
          </div>
        </div>

        <div class="row g-2 mt-2">
          <div class="col-md-6">
            <label class="form-label">Ng∆∞·ª°ng ‚Äúth·ª±c hi·ªán d∆∞·ªõi‚Äù (ph√∫t)</label>
            <input id="minMinutes" type="number" class="form-control" value="6" min="1" step="1">
          </div>
          <div class="col-md-6">
            <label class="form-label">So kh·ªõp tr√πng theo (ph√∫t l√†m tr√≤n)</label>
            <input id="roundToMin" type="number" class="form-control" value="1" min="1" step="1">
          </div>
        </div>
      </div>
    </div>

    <div class="d-flex flex-wrap gap-2 mt-3">
      <button id="btnRun" class="btn btn-primary" disabled>üîé Ph√¢n t√≠ch</button>
      <button id="btnExport" class="btn btn-success" disabled>Xu·∫•t CSV l·ªói</button>
      <button id="btnClear" class="btn btn-outline-secondary">Xo√° k·∫øt qu·∫£</button>
    </div>

    <div id="diagBox" class="alert alert-warning mt-3 d-none diag"></div>
  </div>

  <div class="card shadow-sm p-4 mb-3">
    <div class="row g-3">
      <div class="col-md-3">
        <div class="muted">T·ªïng d√≤ng ƒë·ªçc</div>
        <div id="kpiRows" class="kpi">‚Äî</div>
      </div>
      <div class="col-md-3">
        <div class="muted">D√≤ng X-quang</div>
        <div id="kpiXQ" class="kpi">‚Äî</div>
      </div>
      <div class="col-md-3">
        <div class="muted">S·ªë l·ªói</div>
        <div id="kpiErrors" class="kpi">‚Äî</div>
      </div>
      <div class="col-md-3">
        <div class="muted">Ngu·ªìn d·ªØ li·ªáu</div>
        <div id="kpiSheet" class="kpi">‚Äî</div>
      </div>
    </div>

    <hr class="my-3">

    <div class="row g-2 align-items-end">
      <div class="col-lg-5">
        <label class="form-label">L·ªçc nhanh</label>
        <input id="q" class="form-control" placeholder="VD: Tr√πng th·ªùi gian b·∫Øt ƒë·∫ßu, XQ.2..., t√™n KTV, m√£ KCB..." />
      </div>
      <div class="col-lg-3">
        <label class="form-label">Ch·ªâ hi·ªÉn th·ªã lo·∫°i l·ªói</label>
        <select id="typeFilter" class="form-select">
          <option value="">(T·∫•t c·∫£)</option>
        </select>
      </div>
      <div class="col-lg-2">
        <label class="form-label">S·∫Øp x·∫øp</label>
        <select id="sortBy" class="form-select">
          <option value="time">Th·ªùi gian</option>
          <option value="type">Lo·∫°i l·ªói</option>
          <option value="machine">M√£ m√°y ‚Üí Th·ªùi gian</option>
        </select>
      </div>
      <div class="col-lg-2 d-grid">
        <button id="btnCopySummary" class="btn btn-outline-primary">Copy t√≥m t·∫Øt</button>
      </div>
    </div>

    <div class="table-responsive mt-3" style="max-height:60vh">
      <table class="table table-sm table-hover align-middle">
        <thead>
          <tr>
            <th class="nowrap">#</th>
            <th class="nowrap">Lo·∫°i l·ªói</th>
            <th>M√¥ t·∫£</th>
            <th class="nowrap">M√£ m√°y</th>
            <th class="nowrap">Ng∆∞·ªùi TH</th>
            <th class="nowrap">B√°c sƒ©</th>
            <th class="nowrap">M√£ KCB</th>
            <th>DVKT</th>
            <th class="nowrap">Bƒê</th>
            <th class="nowrap">KT</th>
            <th class="nowrap">Ph√∫t</th>
            <th class="nowrap">D√≤ng li√™n quan</th>
          </tr>
        </thead>
        <tbody id="tbody">
          <tr><td colspan="12" class="text-muted">Ch∆∞a c√≥ d·ªØ li·ªáu. H√£y t·∫£i file v√† b·∫•m <b>Ph√¢n t√≠ch</b>.</td></tr>
        </tbody>
      </table>
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/xlsx@0.19.3/dist/xlsx.full.min.js"></script>
<script>
  const $ = (id) => document.getElementById(id);

  function showDiag(msg, level="warning"){
    const box = $("diagBox");
    box.className = "alert alert-" + (level==="danger" ? "danger" : "warning") + " mt-3 diag";
    box.textContent = msg;
    box.classList.remove("d-none");
  }
  function hideDiag(){ $("diagBox").classList.add("d-none"); $("diagBox").textContent=""; }

  function excelNumberToDate(n) {
    const epoch = Date.UTC(1899, 11, 30);
    const ms = Math.round(n * 86400000);
    return new Date(epoch + ms);
  }

  function toDate(val) {
    if (val == null || val === "") return null;
    if (val instanceof Date && !isNaN(val)) return val;
    if (typeof val === "number" && isFinite(val)) return excelNumberToDate(val);
    if (typeof val === "string") {
      const s = val.trim().replace(/\s+/g, " ");
      const iso = new Date(s);
      if (!isNaN(iso)) return iso;

      const m = s.match(/^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{2,4})(?:\s+(\d{1,2}):(\d{2})(?::(\d{2}))?\s*(AM|PM)?)?$/i);
      if (m) {
        let d = parseInt(m[1],10), mo = parseInt(m[2],10)-1, y = parseInt(m[3],10);
        if (y < 100) y += 2000;
        let hh = m[4] ? parseInt(m[4],10) : 0;
        const mm = m[5] ? parseInt(m[5],10) : 0;
        const ss = m[6] ? parseInt(m[6],10) : 0;
        const ap = m[7] ? m[7].toUpperCase() : null;
        if (ap === "PM" && hh < 12) hh += 12;
        if (ap === "AM" && hh === 12) hh = 0;
        const dt = new Date(y, mo, d, hh, mm, ss);
        if (!isNaN(dt)) return dt;
      }
    }
    return null;
  }

  function fmt(dt) {
    if (!dt) return "";
    try {
      const f = new Intl.DateTimeFormat("vi-VN", {
        timeZone: "Asia/Ho_Chi_Minh",
        year: "numeric", month: "2-digit", day: "2-digit",
        hour: "2-digit", minute: "2-digit"
      });
      return f.format(dt);
    } catch (e) { return dt.toLocaleString(); }
  }

  function safe(v) { return (v==null) ? "" : String(v); }
  function minutesBetween(a,b) { return Math.round((b.getTime()-a.getTime())/60000); }

  // CSV parsing fallback
  function parseCSV(text){
    const lines = text.replace(/\r\n/g,"\n").replace(/\r/g,"\n").split("\n").filter(l=>l.trim()!=="");
    if (!lines.length) return {headers:[], rows:[]};
    const head = lines[0];
    const comma = (head.match(/,/g)||[]).length;
    const semi = (head.match(/;/g)||[]).length;
    const tab = (head.match(/\t/g)||[]).length;
    const delim = tab>0 ? "\t" : (semi>comma ? ";" : ",");

    const splitLine = (line) => {
      const out = [];
      let cur="", inQ=false;
      for (let i=0;i<line.length;i++){
        const ch=line[i];
        if (ch === '"'){
          if (inQ && line[i+1] === '"'){ cur+='"'; i++; }
          else inQ = !inQ;
        } else if (!inQ && ch === delim){
          out.push(cur); cur="";
        } else cur += ch;
      }
      out.push(cur);
      return out.map(s=>s.trim());
    };

    const headers = splitLine(lines[0]);
    const rows = [];
    for (let r=1;r<lines.length;r++){
      const cols = splitLine(lines[r]);
      if (cols.every(c=>c==="")) continue;
      rows.push(cols);
    }
    return {headers, rows, delim};
  }

  function normHeader(h){ return safe(h).trim().toLowerCase().replace(/\s+/g," "); }
  function mapHeaders(headers){
    const idx = {}; headers.forEach((h,i)=> idx[normHeader(h)] = i);
    const pick = (cands) => {
      for (const c of cands){ const k=normHeader(c); if (k in idx) return idx[k]; }
      for (const c of cands){
        const k=normHeader(c);
        for (const key in idx){ if (key.includes(k)) return idx[key]; }
      }
      return -1;
    };
    return {
      ten: pick(["t√™n dvkt","ten dvkt","dvkt"]),
      maMay: pick(["m√£ m√°y","ma may"]),
      nguoiTH: pick(["ng∆∞·ªùi th·ª±c hi·ªán","nguoi thuc hien"]),
      bacSi: pick(["b√°c sƒ©","bac si"]),
      maKCB: pick(["m√£ kcb","ma kcb"]),
      start: pick(["ng√†y th·ª±c hi·ªán yl","ng√†y th·ª±c hi·ªán"]),
      end: pick(["ng√†y k·∫øt qu·∫£"])
    };
  }

  function bucketTime(dt, roundToMin) {
    if (!dt) return "";
    const bucket = Math.max(1, roundToMin) * 60000;
    const rounded = Math.floor(dt.getTime() / bucket) * bucket;
    return String(rounded);
  }

  function isXQ(row, byService, byMachine) {
    const ten = safe(row.ten).toLowerCase();
    const ma = safe(row.maMay).trim().toUpperCase();
    const okService = byService ? (ten.includes("x-quang") || ten.includes("x quang") || ten.includes("xq") || ten.includes("x-ray") || ten.includes("xray")) : false;
    const okMachine = byMachine ? (ma.startsWith("XQ")) : false;
    if (byService && byMachine) return okService || okMachine;
    if (byService) return okService;
    if (byMachine) return okMachine;
    return true;
  }

  function mkErr(type, row, desc, relatedRows=[]) {
    const dur = (row.start && row.end) ? minutesBetween(row.start, row.end) : null;
    const related = relatedRows.length ? relatedRows.map(r=>r.rownum).join(", ") : "";
    return {
      type, desc,
      rownum: row.rownum,
      maMay: row.maMay,
      nguoiTH: row.nguoiTH,
      bacSi: row.bacSi,
      maKCB: row.maKCB,
      ten: row.ten,
      start: row.start,
      end: row.end,
      duration: dur,
      related
    };
  }

  function analyzeXQ(rows, opts) {
    const errors = [];
    const roundToMin = Math.max(1, opts.roundToMin);
    const minM = Math.max(1, opts.minMinutes);

    for (const r of rows) {
      if (r.start && r.end) {
        const dur = minutesBetween(r.start, r.end);
        if (dur >= 0 && dur < minM) {
          errors.push(mkErr("Th·ª±c hi·ªán d∆∞·ªõi 6 ph√∫t", r, `Th·ªùi gian th·ª±c hi·ªán ${dur} ph√∫t < ${minM} ph√∫t`, []));
        }
      }
    }

    const mapStart = new Map();
    for (const r of rows) {
      if (!r.start) continue;
      const key = bucketTime(r.start, roundToMin);
      if (!mapStart.has(key)) mapStart.set(key, []);
      mapStart.get(key).push(r);
    }
    for (const [key, arr] of mapStart.entries()) {
      if (arr.length < 2) continue;
      const machines = new Set(arr.map(x => safe(x.maMay).trim()).filter(Boolean));
      if (machines.size >= 2) {
        for (const r of arr) {
          const others = arr.filter(x => x !== r);
          const otherMachines = Array.from(new Set(others.map(x=>safe(x.maMay).trim()).filter(Boolean))).join(", ");
          const desc = `C√πng Bƒê (${fmt(r.start)}) nh∆∞ng kh√°c m√°y. M√°y kh√°c: ${otherMachines || "(kh√¥ng r√µ)"}`;
          errors.push(mkErr("Tr√πng th·ªùi gian b·∫Øt ƒë·∫ßu", r, desc, others));
        }
      }
    }

    const mapEnd = new Map();
    for (const r of rows) {
      if (!r.end) continue;
      const key = bucketTime(r.end, roundToMin);
      if (!mapEnd.has(key)) mapEnd.set(key, []);
      mapEnd.get(key).push(r);
    }
    for (const [key, arr] of mapEnd.entries()) {
      if (arr.length < 2) continue;
      for (const r of arr) {
        const others = arr.filter(x => x !== r);
        const desc = `Tr√πng KT (${fmt(r.end)}) v·ªõi ${others.length} ca kh√°c`;
        errors.push(mkErr("Tr√πng th·ªùi gian k·∫øt th√∫c", r, desc, others));
      }
    }

    const seen = new Set();
    const out = [];
    for (const e of errors) {
      const sig = [e.type, e.rownum, bucketTime(e.start, roundToMin), bucketTime(e.end, roundToMin), e.related].join("|");
      if (seen.has(sig)) continue;
      seen.add(sig);
      out.push(e);
    }
    return out;
  }

  function setKPIs(rowsCount, xqCount, errors, sourceName) {
    $("kpiRows").textContent = rowsCount ?? "‚Äî";
    $("kpiXQ").textContent = xqCount ?? "‚Äî";
    $("kpiErrors").textContent = errors ? errors.length : "‚Äî";
    $("kpiSheet").textContent = sourceName ?? "‚Äî";
  }

  function fillTypeFilter(errors) {
    const sel = $("typeFilter");
    const cur = sel.value;
    const types = Array.from(new Set(errors.map(e=>e.type))).sort();
    sel.innerHTML = `<option value="">(T·∫•t c·∫£)</option>` + types.map(t=>`<option value="${escapeHtml(t)}">${escapeHtml(t)}</option>`).join("");
    sel.value = cur;
  }

  function escapeHtml(s) {
    return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'}[c]));
  }

  function render(errors) {
    const q = $("q").value.trim().toLowerCase();
    const typeF = $("typeFilter").value;
    const sortBy = $("sortBy").value;

    let items = errors.slice();
    if (typeF) items = items.filter(e=>e.type===typeF);
    if (q) {
      items = items.filter(e => {
        const blob = [e.type,e.desc,e.maMay,e.nguoiTH,e.bacSi,e.maKCB,e.ten,fmt(e.start),fmt(e.end),e.rownum,e.related].join(" ").toLowerCase();
        return blob.includes(q);
      });
    }

    if (sortBy === "type") items.sort((a,b)=>a.type.localeCompare(b.type) || (a.start?.getTime()||0)-(b.start?.getTime()||0));
    else if (sortBy === "machine") items.sort((a,b)=>safe(a.maMay).localeCompare(safe(b.maMay)) || (a.start?.getTime()||0)-(b.start?.getTime()||0));
    else items.sort((a,b)=>(a.start?.getTime()||0)-(b.start?.getTime()||0));

    const tb = $("tbody");
    if (!items.length) {
      tb.innerHTML = `<tr><td colspan="12" class="text-muted">Kh√¥ng c√≥ l·ªói theo b·ªô l·ªçc hi·ªán t·∫°i.</td></tr>`;
      return;
    }

    tb.innerHTML = items.map((e, idx) => `
      <tr class="rowerr">
        <td class="nowrap">${idx+1}</td>
        <td class="nowrap"><span class="badge text-bg-warning">${escapeHtml(e.type)}</span></td>
        <td>${escapeHtml(e.desc)}</td>
        <td class="nowrap">${escapeHtml(safe(e.maMay))}</td>
        <td class="nowrap">${escapeHtml(safe(e.nguoiTH))}</td>
        <td class="nowrap">${escapeHtml(safe(e.bacSi))}</td>
        <td class="nowrap">${escapeHtml(safe(e.maKCB))}</td>
        <td>${escapeHtml(safe(e.ten))}</td>
        <td class="nowrap">${escapeHtml(fmt(e.start))}</td>
        <td class="nowrap">${escapeHtml(fmt(e.end))}</td>
        <td class="nowrap">${e.duration==null ? "" : e.duration}</td>
        <td class="nowrap">${e.related ? `Li√™n quan d√≤ng: ${escapeHtml(e.related)}` : ""}</td>
      </tr>
    `).join("");
  }

  function exportCSV(errors) {
    const headers = ["LoaiLoi","MoTa","MaMay","NguoiTH","BacSi","MaKCB","TenDVKT","BatDau","KetThuc","Phut","Dong","DongLienQuan"];
    const rows = errors.map(e => [
      e.type, e.desc, e.maMay, e.nguoiTH, e.bacSi, e.maKCB, e.ten, fmt(e.start), fmt(e.end),
      e.duration ?? "", e.rownum ?? "", e.related ?? ""
    ].map(v => `"${String(v??"").replace(/"/g,'""')}"`).join(","));
    const csv = headers.join(",") + "\n" + rows.join("\n");
    const blob = new Blob([csv], {type:"text/csv;charset=utf-8"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `loi_xquang_${new Date().toISOString().slice(0,10)}.csv`;
    a.click();
    URL.revokeObjectURL(url);
  }

  let allRows = [];
  let xqRows = [];
  let analyzedErrors = [];
  let sourceName = "‚Äî";
  let selectedFile = null;

  function canReadExcel(){ return typeof XLSX !== "undefined"; }

  async function loadDataFromFile(f){
    hideDiag();
    selectedFile = f;
    allRows = []; xqRows = []; analyzedErrors = [];
    $("btnExport").disabled = true;
    $("tbody").innerHTML = `<tr><td colspan="12" class="text-muted">ƒê√£ t·∫£i file. B·∫•m <b>Ph√¢n t√≠ch</b> ƒë·ªÉ x·ª≠ l√Ω‚Ä¶</td></tr>`;

    if (!f){ $("btnRun").disabled = true; return; }

    const name = f.name || "‚Äî";
    const ext = name.split(".").pop().toLowerCase();

    if (ext === "csv" || ext === "txt" || ext === "tsv"){
      const text = await f.text();
      const parsed = parseCSV(text);
      const col = mapHeaders(parsed.headers);

      const missing = [];
      if (col.start < 0) missing.push("Ng√†y th·ª±c hi·ªán YL");
      if (col.end < 0) missing.push("Ng√†y k·∫øt qu·∫£");
      if (col.ten < 0) missing.push("T√™n DVKT");
      if (col.maMay < 0) missing.push("M√£ m√°y");
      if (missing.length){
        showDiag("CSV thi·∫øu c·ªôt b·∫Øt bu·ªôc: " + missing.join(", ") + "\nH√£y ki·ªÉm tra h√†ng ti√™u ƒë·ªÅ gi·ªëng Sheet1.", "danger");
        $("btnRun").disabled = true;
        return;
      }

      allRows = parsed.rows.map((cols, idx)=>({
        rownum: idx+2,
        ten: cols[col.ten] ?? "",
        maMay: cols[col.maMay] ?? "",
        nguoiTH: col.nguoiTH>=0 ? (cols[col.nguoiTH] ?? "") : "",
        bacSi: col.bacSi>=0 ? (cols[col.bacSi] ?? "") : "",
        maKCB: col.maKCB>=0 ? (cols[col.maKCB] ?? "") : "",
        start: toDate(cols[col.start]),
        end: toDate(cols[col.end]),
      }));

      sourceName = "CSV: " + name;
      setKPIs(allRows.length, "‚Äî", [], sourceName);
      $("btnRun").disabled = false;
      return;
    }

    if ((ext==="xlsx" || ext==="xls") && !canReadExcel()){
      showDiag("Kh√¥ng t·∫£i ƒë∆∞·ª£c th∆∞ vi·ªán XLSX t·ª´ CDN (m·∫°ng c√≥ th·ªÉ ch·∫∑n). \n‚û°Ô∏è C√°ch x·ª≠ l√Ω: Excel ‚Üí Save As ‚Üí CSV UTF-8 ‚Üí t·∫£i CSV v√†o trang n√†y.", "danger");
      $("btnRun").disabled = true;
      return;
    }

    if (ext==="xlsx" || ext==="xls"){
      const buf = await f.arrayBuffer();
      const wb = XLSX.read(buf, {type:"array", cellDates:true, raw:true});
      const sheetName = (wb.SheetNames.includes("Sheet1") ? "Sheet1" : wb.SheetNames[0]);
      const ws = wb.Sheets[sheetName];
      const aoa = XLSX.utils.sheet_to_json(ws, {header: 1, raw: true, defval: null});

      // find header row
      let headerRowIdx = -1;
      for (let r=0;r<Math.min(120, aoa.length);r++){
        const joined = (aoa[r]||[]).map(x=>safe(x)).join(" | ");
        if (joined.includes("Ng√†y th·ª±c hi·ªán") && joined.includes("Ng√†y k·∫øt qu·∫£")) { headerRowIdx = r; break; }
      }
      if (headerRowIdx === -1) headerRowIdx = 0;

      const headers = (aoa[headerRowIdx]||[]).map(h=>safe(h).trim());
      const col = mapHeaders(headers);

      const missing = [];
      if (col.start < 0) missing.push("Ng√†y th·ª±c hi·ªán YL");
      if (col.end < 0) missing.push("Ng√†y k·∫øt qu·∫£");
      if (col.ten < 0) missing.push("T√™n DVKT");
      if (col.maMay < 0) missing.push("M√£ m√°y");
      if (missing.length){
        showDiag("Excel thi·∫øu c·ªôt b·∫Øt bu·ªôc: " + missing.join(", ") + "\nH√£y ki·ªÉm tra header trong Sheet1.", "danger");
        $("btnRun").disabled = true;
        return;
      }

      const rows = [];
      for (let r=headerRowIdx+1; r<aoa.length; r++){
        const row = aoa[r] || [];
        const nonEmpty = row.some(v => v!=null && safe(v).trim()!=="");
        if (!nonEmpty) continue;
        rows.push({row, rownum: r+1});
      }

      allRows = rows.map((it)=>({
        rownum: it.rownum,
        ten: it.row[col.ten] ?? "",
        maMay: it.row[col.maMay] ?? "",
        nguoiTH: col.nguoiTH>=0 ? (it.row[col.nguoiTH] ?? "") : "",
        bacSi: col.bacSi>=0 ? (it.row[col.bacSi] ?? "") : "",
        maKCB: col.maKCB>=0 ? (it.row[col.maKCB] ?? "") : "",
        start: toDate(it.row[col.start]),
        end: toDate(it.row[col.end]),
      }));

      sourceName = `Excel: ${name} / ${sheetName}`;
      setKPIs(allRows.length, "‚Äî", [], sourceName);
      $("btnRun").disabled = false;
      return;
    }

    showDiag("ƒê·ªãnh d·∫°ng file ch∆∞a h·ªó tr·ª£. H√£y d√πng .xlsx ho·∫∑c .csv", "danger");
    $("btnRun").disabled = true;
  }

  function runAnalysis(){
    hideDiag();
    if (!selectedFile || allRows.length===0){
      showDiag("Ch∆∞a c√≥ d·ªØ li·ªáu ƒë·ªÉ ph√¢n t√≠ch. H√£y ch·ªçn file tr∆∞·ªõc.", "danger");
      return;
    }

    const byService = $("xqByService").checked;
    const byMachine = $("xqByMachine").checked;
    xqRows = allRows.filter(r => isXQ(r, byService, byMachine));

    const opts = {
      minMinutes: parseInt($("minMinutes").value || "6", 10),
      roundToMin: parseInt($("roundToMin").value || "1", 10),
    };

    analyzedErrors = analyzeXQ(xqRows, opts);
    setKPIs(allRows.length, xqRows.length, analyzedErrors, sourceName);
    fillTypeFilter(analyzedErrors);
    $("btnExport").disabled = analyzedErrors.length === 0;
    render(analyzedErrors);

    if (xqRows.length === 0){
      showDiag("Kh√¥ng t√¨m th·∫•y d√≤ng X-quang theo ti√™u ch√≠ ƒëang b·∫≠t. H√£y th·ª≠ b·∫≠t c·∫£ 2 ti√™u ch√≠ ho·∫∑c ki·ªÉm tra T√™n DVKT/M√£ m√°y trong file.", "warning");
    }
  }

  $("file").addEventListener("change", async (ev)=>{ await loadDataFromFile(ev.target.files?.[0]); });
  $("btnRun").addEventListener("click", runAnalysis);
  $("btnExport").addEventListener("click", ()=>{ if(analyzedErrors.length) exportCSV(analyzedErrors); });

  $("btnClear").addEventListener("click", ()=>{
    selectedFile=null; allRows=[]; xqRows=[]; analyzedErrors=[]; sourceName="‚Äî";
    $("file").value="";
    $("tbody").innerHTML = `<tr><td colspan="12" class="text-muted">Ch∆∞a c√≥ d·ªØ li·ªáu. H√£y t·∫£i file v√† b·∫•m <b>Ph√¢n t√≠ch</b>.</td></tr>`;
    $("typeFilter").innerHTML = `<option value="">(T·∫•t c·∫£)</option>`;
    $("q").value = "";
    setKPIs(null, null, null, "‚Äî");
    $("btnExport").disabled = true;
    $("btnRun").disabled = true;
    hideDiag();
  });

  ["q","typeFilter","sortBy"].forEach(id => {
    $(id).addEventListener("input", ()=>render(analyzedErrors));
    $(id).addEventListener("change", ()=>render(analyzedErrors));
  });

  $("btnCopySummary").addEventListener("click", async ()=>{
    const types = {};
    for (const e of analyzedErrors) types[e.type] = (types[e.type]||0)+1;
    const summary = [
      `${sourceName}`,
      `T·ªïng d√≤ng: ${allRows.length}`,
      `D√≤ng X-quang: ${xqRows.length}`,
      `T·ªïng l·ªói: ${analyzedErrors.length}`,
      `Ph√¢n lo·∫°i: ` + Object.entries(types).sort((a,b)=>b[1]-a[1]).map(([t,n])=>`${t}: ${n}`).join(", ")
    ].join("\n");
    try{ await navigator.clipboard.writeText(summary);
      $("btnCopySummary").textContent="ƒê√£ copy ‚úî";
      setTimeout(()=>$("btnCopySummary").textContent="Copy t√≥m t·∫Øt", 1200);
    }catch(e){ showDiag(summary, "warning"); }
  });

  // Startup hint
  window.addEventListener("load", ()=>{
    if (!canReadExcel()){
      showDiag("L∆∞u √Ω: Kh√¥ng t·∫£i ƒë∆∞·ª£c th∆∞ vi·ªán XLSX t·ª´ CDN. B·∫°n v·∫´n c√≥ th·ªÉ d√πng file CSV (Excel ‚Üí Save As ‚Üí CSV UTF-8).", "warning");
    }
  });
</script>
</body>
</html>
